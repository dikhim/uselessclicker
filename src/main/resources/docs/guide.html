<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Guide</title>
</head>
<body>
<p><a href="#interface">Интерфейс</a><br/>
    <a href="#controlObjects">Объекты управления</a><br/>
    <a href="#firstScript">Первый скрипт</a><br/>
    <a href="#loops">Циклы</a><br/>
    <a href="#functions">Функции</a><br/>
    <a href="#classesAndObjects">Классы и объекты</a><br/>
    <a href="#keyAndMouseObjects">Работа с клавиатурой и мышью</a><br/>
    <a href="#mouseMovement">Перемещение курсора</a><br/>
    <a href="#delays">Задержки</a><br/>
    <a href="#delaySystem">Система задержек</a><br/>
    <a href="#speedAndMultiplier">Изменение скорости или множитель задержек</a><br/>
    <a href="#timeSynchronizationCombinedRun">Синхронизация затраченного времени в методе combined.run</a><br/><br/>
    <a href="#recording">Захват событий</a><br/><br/><br/>
    <a name="interface"></a><br/>
    <strong class="text-strong">Интерфейс</strong><br/>
    Верхнея панель управления содержит основные элементы управления работы с приложением. <br/>Снизу расположено два текстовых поля: верхнее ; для редактирования скрипта (поле редактирования), который будет выполняться программой, нижнее ; для вывода системных сообщений.
</p>
<ul>
    <li>Новый; создать новый файл</li>
    <li>Открыть; открыть существующий файл</li>
    <li>Сохранить; сохранить открытый файл. Если файл не был открыт, то выведется окно с предложением выбрать
        местоположение для нового файла
    </li>
    <li>Сохр. как; сохранить скрипт в новом файле. Если до этого был открыт другой файл то открытый файл остается
        неизменным.
    </li>
    <li>Запуск; запустить скрипт находящийся в поле редактирования на обработку. Если до этого был запущен ругой
        скрипт то он будет экстренно приостановлен
    </li>
    <li>Стоп; приостановить запущенный скрипт</li>
    <li>Сервер; открыть окно для настройки и запуска сервера</li>
    <li>Настройки; открыть окно с основными настройками приложения</li>
    <li>О программе - открыть окно с информацие о программе и разработчиках</li>
</ul>
<p><a name="controlObjects"></a><br/><strong class="text-strong">Объекты управления</strong><br/><span>Для создания сценариев в приложение используется&nbsp;</span><strong
        class="text-strong">"JavaScript"</strong><span>&nbsp;под движком&nbsp;</span><strong class="text-strong">"Nashorn"</strong><span>. Это означает, что может использоваться полный синтаксис и библиотеки поддерживаемые данным движком. Полную информацию о поддерживаемых библиотеках и синтаксисе можете найти здесь ***.&nbsp;</span><br/><span>Для управления компьютером в окружение скрипта введены несколько основных объектов, которые отображаю основные элементы компьютера.</span><br/><span>Перечень доступных объектов:</span>
</p>
<ul>
    <li>mouse - мышь</li>
    <li>key - клавиатура</li>
    <li>combined - комбинированный объект для работы с мышью и клавиатурой</li>
    <li>system - система</li>
    <li>clipboard - буфер обмена</li>
</ul>
<p><span>Доступ к параметрам и методом объекта осуществляется через оператор точку.&nbsp;</span><br/><br/><a
        name="firstScript"></a><br/><strong class="text-strong">Первый скрипт</strong><br/><span>Напишем первый скрипт. Вставьте следующий код в поле редактирования и выполните скрипт нажав кнопку "Запуск".</span>
</p>
<div class="codebox">
    <p>CODE:<span>&nbsp;</span><a href="https://3bytes.pp.ua/viewtopic.php?f=5&amp;t=4#"
                                  onclick="selectCode(this); return false;">SELECT ALL</a></p>
    <pre><code>system.println('Hello world);</code></pre>
</div>
<p><span>Если все сделано правильно, то вы увидите в поле вывода сообщение "Hello world". Системный объект содержит методы для работы с системой, такие как вывод системных сообщений или приостановка выполнения. При выводе сообщений сообщения выводятся и в стандартный поток вывода. Для проверки этого можете запустить приложение через консоль.&nbsp;</span><br/><span>Так что, для работы с любым из объектов можно выделить основный принцип доступа</span>
</p>
<div class="codebox">
    <p>CODE:<span>&nbsp;</span><a href="https://3bytes.pp.ua/viewtopic.php?f=5&amp;t=4#"
                                  onclick="selectCode(this); return false;">SELECT ALL</a></p>
    <pre><code>объект.метод('текстовый параметр',параметр);</code></pre>
</div>
<p><span>Полный список доступных объектов и их методов можно найти в документации либо пройти в правое меню в подпункт "Шаблоны", где можно вставить нужный шаблон и прочитать краткое описание для данного метода.</span><br/><br/><a
        name="loops"></a><br/><strong class="text-strong">Циклы</strong><br/><span>Напишем свой первый цикл. Пускай нам нужно вывести все числа от одного десяти в консоль. Нужный шаблон для цикла можно найти во вкладке&nbsp;</span><strong
        class="text-strong">"Шаблоны&gt;Язык&gt;loop for i++"</strong><span>. Будет вставлен следующий код:</span></p>
<div class="codebox">
    <p>CODE:<span>&nbsp;</span><a href="https://3bytes.pp.ua/viewtopic.php?f=5&amp;t=4#"
                                  onclick="selectCode(this); return false;">SELECT ALL</a></p>
    <pre><code>for(i=0;i&lt;10;i++){
  
}
</code></pre>
</div>
<p><span>Данный код выполняет перебор от 0 до 10. Вы можете найти другие циклы во вкладке с шаблонами для убывающего цикла или цикла while.</span><br/><span>Теперь добавим вывод числа в консоль методом&nbsp;</span><strong
        class="text-strong">"sytem.println()"</strong><span>. Можно использовать метод system.print(), который выполняет ту же работу, но не ставит в конце сообщения перенос строки.</span><br/><span>Скопируйте следующий код и запустите скрипт. Проверьте что все выполняется корректно и в поле вывода появились записи 'i=0' до 9.</span>
</p>
<div class="codebox">
    <p>CODE:<span>&nbsp;</span><a href="https://3bytes.pp.ua/viewtopic.php?f=5&amp;t=4#"
                                  onclick="selectCode(this); return false;">SELECT ALL</a></p>
    <pre><code>for(i=0;i&lt;10;i++){
    system.println('i='+i); 
}
</code></pre>
</div>
<p><a name="functions"></a><br/><strong class="text-strong">Функции</strong><br/><span>Для создания функции добавим шаблон из меню "Шаблоны&gt;Язык&gt;function echo". Данный пункт вставляет код для так называемой эхо-функции, которая принимает значение и возвращает его. Вынесем код указанный выше в функцию и добавим пару вызовов данной функции. Код приведен ниже.&nbsp;</span>
</p>
<div class="codebox">
    <p>CODE:<span>&nbsp;</span><a href="https://3bytes.pp.ua/viewtopic.php?f=5&amp;t=4#"
                                  onclick="selectCode(this); return false;">SELECT ALL</a></p>
    <pre><code>function count(n){
    for(i=0;i&lt;n;i++){
        system.println('i='+i); 
    }
}
system.sleep(2000);
count(2);
system.sleep(2000);
count(3);
</code></pre>
</div>
<p><span>При запуске скрипта обратите внимание, что вывод в консоль производится не сразу, а с периодичность в две секунды. Здесь для наглядности используется метод "system.sleep()" который указывает, что системы следует подождать указанное количество миллисекунд. 2000 миллисекунд = секунды.&nbsp;</span><br/><br/><a
        name="classesAndObjects"></a><br/><strong class="text-strong">Классы и объекты</strong><br/><span>Для создания класса добавим шаблон из меню "Шаблоны&gt;Язык&gt;class". В поле редактирования будет вставлен шаблон функции с именем "Class". Оператор "class" не поддерживается, потому придется использовать такую конструкцию.</span>
</p>
<div class="codebox">
    <p>CODE:<span>&nbsp;</span><a href="https://3bytes.pp.ua/viewtopic.php?f=5&amp;t=4#"
                                  onclick="selectCode(this); return false;">SELECT ALL</a></p>
    <pre><code>function Class (name) {
  this.name = name; // поле класса
  this.echo = function(text){ // метод класса
    return text;
  };
}
</code></pre>
</div>
<p><span>В шаблоне вставляется класс с одним полем и эхо-функцией.&nbsp;</span><br/><span>Объект можно создать при помощи следующего кода</span>
</p>
<div class="codebox">
    <p>CODE:<span>&nbsp;</span><a href="https://3bytes.pp.ua/viewtopic.php?f=5&amp;t=4#"
                                  onclick="selectCode(this); return false;">SELECT ALL</a></p>
    <pre><code>var obj = new CLass();</code></pre>
</div>
<p><span>Приведем более наглядный пример с использованием классов и объектов. Создадим объект "math" который сможет хранить в себе число и увеличивать его на единицу.</span>
</p>
<div class="codebox">
    <p>CODE:<span>&nbsp;</span><a href="https://3bytes.pp.ua/viewtopic.php?f=5&amp;t=4#"
                                  onclick="selectCode(this); return false;">SELECT ALL</a></p>
    <pre><code>function Number(n) {
  this.n = n; // поле класса
  this.inc = function(){ // метод "увеличить число на 1"
    n++;
  };
  this.get = function(){ // метод "получить значение"
    return n;
  };
}

var myNumber = new Number(0); // создание объекта
myNumber.inc(); // вызов метода 3 раза
myNumber.inc();
myNumber.inc();
system.println('My number = '+myNumber.get()); // вывод
</code></pre>
</div>
<p><a name="keyAndMouseObjects"></a><br/><strong class="text-strong">Работа с клавиатурой и мышью</strong><br/><span>Для работы с мышью и клавиатурой используются два встроенных объекта "mouse" и "key".</span><br/><span>Рассмотрим пример кода для работы с объектом клавиатуры. Вставьте код, запустите его и выберите любое текстовое поле. После запуска кода на все про все у вас есть 5 секунд. Поторопитесь!</span>
</p>
<div class="codebox">
    <p>CODE:<span>&nbsp;</span><a href="https://3bytes.pp.ua/viewtopic.php?f=5&amp;t=4#"
                                  onclick="selectCode(this); return false;">SELECT ALL</a></p>
    <pre><code>system.sleep(5000);
key.press('H');
key.release('H');

key.perform('E','PRESS');
key.perform('E','RELEASE');

key.type('L L O SPACE W O R L D');
</code></pre>
</div>
<p><span>Данный скрипт генерирует события нажатия и отпускания клавиш клавиатуры. В нем используются основные доступные методы. В качестве параметров используются имена клавиш, с которыми вы хотите работать, записанные через пробел. Если в параметре указано больше одной клавиши, то события для каждой клавиши будут вызваны последовательно в порядке следования. Так, запись</span>
</p>
<div class="codebox">
    <p>CODE:<span>&nbsp;</span><a href="https://3bytes.pp.ua/viewtopic.php?f=5&amp;t=4#"
                                  onclick="selectCode(this); return false;">SELECT ALL</a></p>
    <pre><code>key.press('CONTROL A')</code></pre>
</div>
<p><span>эквивалентна записи</span></p>
<div class="codebox">
    <p>CODE:<span>&nbsp;</span><a href="https://3bytes.pp.ua/viewtopic.php?f=5&amp;t=4#"
                                  onclick="selectCode(this); return false;">SELECT ALL</a></p>
    <pre><code>key.press('CONTROL'); 
key.press('A');</code></pre>
</div>
<p><span>Метод "type" генерирует последовательно для каждой клавиши события нажатия и отпускания клавиш. Строчка</span>
</p>
<div class="codebox">
    <p>CODE:<span>&nbsp;</span><a href="https://3bytes.pp.ua/viewtopic.php?f=5&amp;t=4#"
                                  onclick="selectCode(this); return false;">SELECT ALL</a></p>
    <pre><code>key.type('H E L L O SPACE W O R L D');</code></pre>
</div>
<p><span>последовательно генерирует события для вывода текста&nbsp;</span><strong class="text-strong">"hello
    world"</strong><span>. Помните, что метод только генерирует указанные события, а не в действительности печатает переданный ему в параметре текст и запись&nbsp;</span><strong
        class="text-strong">"key.type('Hello World);"</strong><span>&nbsp;работать не будет, так как для отображения заглавных букв нужны события нажатия клавиш&nbsp;</span><strong
        class="text-strong">SHIFT</strong><span>&nbsp;или&nbsp;</span><strong
        class="text-strong">CAPS_LOCK</strong><span>, а пробел используется для разделения названий клавиш.</span><br/><br/><span>Для работы с кнопками мыши существуют аналогичные методы генерирующие нажатия, отпускания или клики. Методы отличаются названиями но в сущности выполняют ту же работу. Посмотрите приведенный ниже код.</span>
</p>
<div class="codebox">
    <p>CODE:<span>&nbsp;</span><a href="https://3bytes.pp.ua/viewtopic.php?f=5&amp;t=4#"
                                  onclick="selectCode(this); return false;">SELECT ALL</a></p>
    <pre><code>mouse.press('LEFT');
mouse.release('LEFT');

mouse.click('RIGHT');
</code></pre>
</div>
<p><span>В стороне от клавиш и кнопок стоит колесо мыши, которое зачастую сочетает в себе среднею кнопку мыши.</span>
</p>
<div class="codebox">
    <p>CODE:<span>&nbsp;</span><a href="https://3bytes.pp.ua/viewtopic.php?f=5&amp;t=4#"
                                  onclick="selectCode(this); return false;">SELECT ALL</a></p>
    <pre><code>mouse.click('MIDDLE');

mouse.wheel('DOWN',3);
</code></pre>
</div>
<p><span>Для генерации события нажатия средней кнопки мыши используется аналогичная запись как и с другими кнопками. Для указания работы с колесом прокрутки нужно указывать уже два параметра: направление прокрутки&nbsp;</span><strong
        class="text-strong">"UP/DOWN"</strong><span>&nbsp;и числовой параметр количество строк.</span><br/><br/><a
        name="mouseMovement"></a><br/><strong class="text-strong">Перемещение курсора</strong><br/><span>Для симуляция передвижения мыши существую два основных метода&nbsp;</span><strong
        class="text-strong">"mouse.move(dx,dy)"</strong><span>&nbsp;и&nbsp;</span><strong class="text-strong">"mouse.moveTo(x,y)"</strong><span>.&nbsp;</span><br/><span>Метод&nbsp;</span><strong
        class="text-strong">"move"</strong><span>&nbsp;перемещает курсор относительно текущего положения курсора, то есть, по относительным координатам. Запустите следующий код и обратите внимание на начальное положение курсора и в каком направлении он движется. Параметры могут быть как положительные так и отрицательные. Если параметр отрицательный, то это указывает на обратное смещение по оси координат и курсор будет двигаться в обратную сторону.&nbsp;</span>
</p>
<div class="codebox">
    <p>CODE:<span>&nbsp;</span><a href="https://3bytes.pp.ua/viewtopic.php?f=5&amp;t=4#"
                                  onclick="selectCode(this); return false;">SELECT ALL</a></p>
    <pre><code>for(i=0;i&lt;100;i++){
    mouse.move(2,2);
}
</code></pre>
</div>
<p><span>Метод&nbsp;</span><strong class="text-strong">"moveTo"<span>&nbsp;</span></strong><span>передвигает курсор в указанную точку экрана, то есть, передвигает его в указанные абсолютные координаты, где точка 0,0 это левый верхний угол экрана. Координаты не могут быть больше размера вашего монитора или меньше нуля. Нужно быть внимательным с указанием абсолютных координат. Но беспокоиться по этому поводу не стоит, курсор никогда не выйдет за пределы экрана и вы не увидите никаких ошибок.&nbsp;</span><br/><br/><span>for(i=0;i&lt;100;i++){</span><br/><span>mouse.moveTo(i,i);</span><br/><span>}&nbsp;</span><br/><br/><span>Существует также множество комбинированных методом, которые упрощают работу с мышью. Все они подчиняются определенным правилам наименования. Если в конце добавляется окончание&nbsp;</span><strong
        class="text-strong">"At"</strong><span>, это означает, что данное событие будет произведено в указанной точке, то есть, курсор сначала будет передвинут в указанную точку и потом будет произведено событие. Если метод начинается со слов&nbsp;</span><strong
        class="text-strong">"moveAnd"</strong><span>, то это означает, что курсор будет сначала передвинут относительно предыдущего положения и потом будет произведено событие.&nbsp;</span><br/><span>Для простоты запоминания</span>
</p>
<ul>
    <li><strong class="text-strong">At</strong><span>&nbsp;</span>&ndash; абсолютное перемещение в указанную точку;</li>
    <li><strong class="text-strong">moveAnd</strong><span>&nbsp;</span>&ndash; относительное перемещение.</li>
</ul>
<p><span>Стоит понимать, что данные методы не добавляют нового функционала, а лишь упрощают запись и чтение кода. К примеру, ниже приведены примеры кода, который выполняет абсолютно одинаковые фунции.</span>
</p>
<div class="codebox">
    <p>CODE:<span>&nbsp;</span><a href="https://3bytes.pp.ua/viewtopic.php?f=5&amp;t=4#"
                                  onclick="selectCode(this); return false;">SELECT ALL</a></p>
    <pre><code>
mouse.moveTo(0,0);// переместить курсор в точку 0,0 
mouse.press('LEFT');// нажать левую кнопку мыши
mouse.release('LEFT');// отпустить левую кнопку мыши

// аналогично
mouse.moveTo(0,0);
mouse.click('LEFT');

// аналогично
mouse.clickAt('LEFT',0,0);



mouse.press('LEFT');// передвинуть курсор вправо
mouse.move(20,0);// нажать левую кнопку мыши
mouse.release('LEFT');// отпустить левую кнопку мыши

// аналогично
mouse.press('LEFT');
mouse.moveAndRelease('LEFT',20,0);
</code></pre>
</div>
<p><a name="delays"></a><br/><strong class="text-strong">Задержки</strong><br/><span>Между любыми событиями и вызовами существуют задержки. Мы пока что писали код, который никак не воспроизводил задержки. Для реализации задержки существует метод&nbsp;</span><strong
        class="text-strong">"system.sleep(delay)"</strong><span>. Он приказывает системе подождать в этом месте скрипта указанное количество миллисекунд и только потом продолжить выполнение скрипта. Задержки используются для симуляции реального поведения пользователя. Реальный человек не может мгновенно напечатать более 100 символов, да и не каждая программа способна корректно обработать ввод такого рода, некоторые события будут просто упущены. Потому, скрипт необходимо замедлять принудительно.&nbsp;</span><br/><span>Внизу приведен пример скрипта для ввода слова&nbsp;</span><strong
        class="text-strong">"Hello",</strong><span>&nbsp;который записан с действий реального человека. Скрипт получился длинный, но он делает ровно то, что в него записали &ndash; печатает слово&nbsp;</span><strong
        class="text-strong">"Hello"</strong><span>.</span></p>
<div class="codebox">
    <p>CODE:<span>&nbsp;</span><a href="https://3bytes.pp.ua/viewtopic.php?f=5&amp;t=4#"
                                  onclick="selectCode(this); return false;">SELECT ALL</a></p>
    <pre><code>key.press('SHIFT');
system.sleep(228);
key.press('H');
system.sleep(65);
key.release('H');
system.sleep(25);
key.release('SHIFT');
system.sleep(142);
key.press('E');
system.sleep(60);
key.release('E');
system.sleep(95);
key.press('L');
system.sleep(65);
key.release('L');
system.sleep(78);
key.press('L');
system.sleep(66);
key.release('L');
system.sleep(102);
key.press('O');
system.sleep(70);
key.release('O');
</code></pre>
</div>
<p><span>Обратите внимание на задержки между событиями. В сумме, это именно то время, которое требуется реальному человеку чтобы напечатать данное слово.&nbsp;</span><br/><span>Без задержек пользовательский ввод невозможен. Можете попробовать выполнить скрипт с нулевыми задержками, он попросту зависнет. Но сначала прочтите полное руководство к системе контроля задержек в событиях.</span><br/><br/><a
        name="delaySystem"></a><br/><strong class="text-strong">Система задержек</strong><br/><span>У каждого события, для каждого объекта, существует своя предустановленная задержка. К примеру вызов метода&nbsp;</span><strong
        class="text-strong">"key.press('BTN')"</strong><span>&nbsp;на самом деле не происходит моментально. Внутри уже встроена, так называемая, задержка нажатия&nbsp;</span><strong
        class="text-strong">"pressDelay"</strong><span>, которая вызывается сразу после того, как событие будет вызвано. То есть, внутренняя структура метода&nbsp;</span><strong
        class="text-strong">"pressDay"</strong><span>&nbsp;выглядит примерно так:</span></p>
<div class="codebox">
    <p>CODE:<span>&nbsp;</span><a href="https://3bytes.pp.ua/viewtopic.php?f=5&amp;t=4#"
                                  onclick="selectCode(this); return false;">SELECT ALL</a></p>
    <pre><code>press('BTN');
sleep(pressDelay);
</code></pre>
</div>
<p><span>Стандартное значение задержки равно 10мс. Внедрение задержки внутрь метода позволяет избавить себя от заботы прописывать задержки после каждого события. Данная задержка может быть задана методом&nbsp;</span><strong
        class="text-strong">"key.setDelay(pressDelay)"</strong><span>, что позволяет гибко настраивать скрипт и не заботится о том, что скрипт может внезапно зависнуть из-за слишком большого количество событий в секунду.&nbsp;</span><br/><span>Аналогичные задержки и методы для их изменения существуют для каждого события:</span>
</p>
<div class="codebox">
    <p>CODE:<span>&nbsp;</span><a href="https://3bytes.pp.ua/viewtopic.php?f=5&amp;t=4#"
                                  onclick="selectCode(this); return false;">SELECT ALL</a></p>
    <pre><code>key.setPressDelay(pressDelay);
key.setReleaseDelay(releaseDealy);
mouse.setPressDelay(pressDelay);
mouse.setReleaseDelay(releaseDelay);
mouse.setWheelDelay(wheelDelay);
mouse.setMoveDelay(moveDelay);
</code></pre>
</div>
<p><span>Так же, для каждой из задержек существуют методы для получения задержки&nbsp;</span><strong
        class="text-strong">"getPressDelay()"</strong><span>&nbsp;и сброса задержки к стандартному значению&nbsp;</span><strong
        class="text-strong">"resetPressDelay()"</strong><span>.</span><br/><br/><a
        name="speedAndMultiplier"></a><br/><strong class="text-strong">Изменение скорости или множитель
    задержек</strong><br/><span>Для более гибкой настройки выполнение скрипта в приложении есть множители задержек&nbsp;</span><strong
        class="text-strong">multiplier</strong><span>&nbsp;и минимальные задержки&nbsp;</span><strong
        class="text-strong">"minDelay"</strong><span>.&nbsp;</span><br/><span>Множитель задержки &ndash; это вещественное число, на которое умножается каждая задержка в данном объекте. Для объекта&nbsp;</span><strong
        class="text-strong">mouse</strong><span>&nbsp;он свой и не зависит от аналогичных в&nbsp;</span><strong
        class="text-strong">key</strong><span>&nbsp;и&nbsp;</span><strong class="text-strong">system</strong><span>. Стандартно он равен 1. Рассмотрим пример</span>
</p>
<div class="codebox">
    <p>CODE:<span>&nbsp;</span><a href="https://3bytes.pp.ua/viewtopic.php?f=5&amp;t=4#"
                                  onclick="selectCode(this); return false;">SELECT ALL</a></p>
    <pre><code>mouse.setMultiplier(0.5);
key.setMultiplier(0.5);
system.setMultiplier(0.5);

mouse.press('LEFT');
mouse.release('LIFT');

system.sleep(500);

key.press('A');
key.release('A');
</code></pre>
</div>
<p><span>Вызовыоми&nbsp;</span><strong class="text-strong">setMultiplier</strong><span>&nbsp;мы устанавливаем множители равными 0,5. Это означает, что во внутренней реализации стандартная задержка, к примеру&nbsp;</span><strong
        class="text-strong">pressDelay</strong><span>, будет умножена на это число, а значит уменьшена вдвое. Таким способом, установив задержку меньше 1 можно ускорить воспроизведение событий, а установив множитель больше 1 замедлить.</span><br/><span>Для удобства использования есть обратный параметр&nbsp;</span><strong
        class="text-strong">speed</strong><span>, который отображает скорость воспроизведения событий. По умолчанию он равен 1, что означает, скрипт будет воспроизводить все событий без изменения задержек. Если установить значение скорости как 2, это означает, что скорость воспроизведения увеличиться в двое.</span><br/><span>Параметр&nbsp;</span><strong
        class="text-strong">speed</strong><span>&nbsp;- это обратная величина к&nbsp;</span><strong class="text-strong">multiplier</strong><span>, изменение одной из них приводит к изменению второй. К примеру, если&nbsp;</span><strong
        class="text-strong">speed = 3</strong><span>, то&nbsp;</span><strong class="text-strong">multiplier =
    0,33</strong><span>.</span><br/><span>Увеличение скорости выполнения скрипта означает, что задержки между событиями уменьшаются. При очень малых значениях задержек скрипт может начать некорректно работать либо полностью прекратить свою работу. Для решения данной проблемы у каждого объекта есть параметр минимальной задержки&nbsp;</span><strong
        class="text-strong">minDelay</strong><span>, который ограничивает минимально возможный предел для каждой задержки. По стандарту он равен 5 миллисекунд. Его так же можно установить соответствующим методом и приравнять к 0, чего делать не рекомендуется. Если же вы решили установить значение минимальной задержки равной 0, то будьте очень внимательные и следите за задержками самостоятельно, иначе скрипт может зависнуть.</span><br/><br/><span>Для большего понимания, рассмотрим наглядный пример для события нажатия клавиши клавиатуры.</span>
</p>
<div class="codebox">
    <p>CODE:<span>&nbsp;</span><a href="https://3bytes.pp.ua/viewtopic.php?f=5&amp;t=4#"
                                  onclick="selectCode(this); return false;">SELECT ALL</a></p>
    <pre><code>// Любое событие происходит моментально
// без каких либо задержек сразу после вызова метода
press('A');
// После события добавляется задержка
if(pressDelay*multiplier &gt;= minDelay){
    // если значение установленной задержки для события,
    // при умножении на множитель дает результат
    // больший или равный минимальной задержке,
    // то подождать получившиеся количество мс.
    sleep(pressDelay*multiplier);
}else{
    // если полученное значение задержки получается меньше
    // чем минимально допустимая задержка,
    // то подождать minDelay миллисекунд. 
    sleep(minDelay);
}
</code></pre>
</div>
<p><a name="combinedObject"></a><br/><strong class="text-strong">Объект combined</strong><br/><span>Данный объект служит для воспроизведения действий как мыши, так и клавиатуры одновременно. Основным его методом является метод&nbsp;</span><strong
        class="text-strong">run</strong><span>. Данный метод получает строку в качестве параметра. Строка представляет из себя компактную запись событий. В каждом символе передаваемой строки закодирован определенный передаваемый параметр. Кодировка происходит в символы юникода (в будущем и другие форматы).&nbsp;</span><br/><br/><span>Рассмотрим подробнее каждое возможное событие и их параметры.</span>
</p>
<ul>
    <li>k# &ndash; key.press(#) зажать клавишу '#'</li>
    <li>K# &ndash; key.release(#) отпустить клавишу '#'</li>
    <li>l &ndash; mouse.press('LEFT') зажать левую кнопку мыши</li>
    <li>L &ndash; mouse.release('LEFT') отпустить левую кнопку мыши</li>
    <li>r &ndash; mouse.press('RIGHT') зажать правую кнопку мыши</li>
    <li>R &ndash; mouse.release('RIGHT') отпустить правую кнопку мыши</li>
    <li>m &ndash; mouse.press('MIDDLE') зажать среднюю кнопку мыши</li>
    <li>M &ndash; mouse.release('MIDDLE') отпустить среднюю кнопку мыши</li>
    <li>w# &ndash; mouse.wheel('DOWN',#) прокрутить колесико вниз '#'</li>
    <li>W# &ndash; mouse.wheel('UP',#) прокрутить колесико вверх '#'</li>
    <li>A#$ &ndash; mouse.moveTo(#,$) передвинуть курсор в точку (#,$)</li>
    <li>X#$ &ndash; mouse.move(#,$) передвинуть курсор на (#,$)</li>
    <li>d# &ndash; system.sleep(#) подождать '#' миллисекунд</li>
    <li>D# &ndash; system.sleep(#*1000) подождать '#' секунд</li>
</ul>
<p><span>Каждое событие записывается с определенной буквы. Некоторые события не имеют параметров(к примеру, зажать левую кнопку мыши), некоторые имеют один параметр(зажать клавишу '#'), а некоторые имеют два параметра (передвинуть курсор в точку (#,$)). При декодировании списка событий каждый из параметров преобразуется в числовое либо буквенное представление и вызывается соответствующий метод.&nbsp;</span><br/><br/><a
        name="timeSynchronizationCombinedRun"></a><br/><strong class="text-strong">Синхронизация затраченного времени в
    методе combined.run</strong><br/><span>Одной из особенностей метода&nbsp;</span><strong
        class="text-strong">run</strong><span>&nbsp;является то, что он проводит синхронизацию по времени выполнения скрипта и реально потраченного времени. Приведем пример: имеется список событий, где записаны различные действия&nbsp;</span><strong
        class="text-strong">"ld#Ld#k#d#K#d#"</strong><span>, используя список событий можно понять, что тут происходит нажатие и отпускание левой кнопки мыши и нажатие и отпускание какой-то клавиши клавиатуры. Переведем эту строку к более наглядному виду и заполним неизвестные параметры:</span>
</p>
<div class="codebox">
    <p>CODE:<span>&nbsp;</span><a href="https://3bytes.pp.ua/viewtopic.php?f=5&amp;t=4#"
                                  onclick="selectCode(this); return false;">SELECT ALL</a></p>
    <pre><code>"ld#Ld#k#d#K#d#" &gt;&gt;&gt;

mouse.press('LEFT');
system.sleep(30);
mouse.release('LEFT');
system.sleep(45);
key.press('A');
system.sleep(100);
key.release('A');
system.sleep(35);
</code></pre>
</div>
<p><span>Между каждым событием присутствует задержка. Теоретическое время выполнение скрипта будет равно сумме всех указанных задержек методом&nbsp;</span><strong
        class="text-strong">"system.sleep() &ndash; 30 + 45 + 100 +35 = 210мс"</strong><span>. Время за которое данный скрипт выполнится на самом деле, будет немного больше(плюс время выполнение самого скрипта), что будет вносить нежелательное отклонение от реального времени. Для компенсации этого отклонения оно вычитается из времени метода&nbsp;</span><strong
        class="text-strong">system.sleep()</strong><span>&nbsp;после каждого события. Внутренние задержки событий также вычитаются из времени задержки. Приведем пример.&nbsp;</span>
</p>
<div class="codebox">
    <p>CODE:<span>&nbsp;</span><a href="https://3bytes.pp.ua/viewtopic.php?f=5&amp;t=4#"
                                  onclick="selectCode(this); return false;">SELECT ALL</a></p>
    <pre><code>mouse.click('LEFT');
system.sleep(100);
</code></pre>
</div>
<p><span>Одно событие клика левой кнопкой мышью и задержка следующая после него. Как было описано в предыдущих главах, метод клика мышью уже содержит в себе стандартные задержки для нажатия кнопки мыши и ее отпускания со всей логикой их вычисления.&nbsp;</span><br/><span>Посчитаем время выполнения данного кода без компенсации задержек.</span><br/><br/><strong
        class="text-strong">(pressDelay =10, releaseDelay =10)<br/>mouse.click('LEFT'); -&gt; pressDelay + releaseDelay
    + 1(накладные расходы)<br/>system.sleep(100); -&gt; sleepTime + 1(накладные<span>&nbsp;</span><br/>общее время = 10
    + 10 + 100 + 2(накладные расходы) =122 мс.<br/>указанное время = 100 мс.<br/>разница = 22
    мс.<br/></strong><br/><br/><span>По предварительному подсчету, в такой ситуации фактическое время выполнения будет не менее 120 мс., а с учетом накладных расходов и того больше. Программа при выполнении метода&nbsp;</span><strong
        class="text-strong">run</strong><span>&nbsp;компенсирует время выполнения отнимая нежелательную разницу из метода&nbsp;</span><strong
        class="text-strong">system.sleep()</strong><span>, фактически, будет выполнен следующий код.</span><br/><span>mouse.click('LEFT');&nbsp;</span><br/><span>system.sleep(78); // отнял 22 мс. разницы</span><br/><span>Таким образом, время выполнения скрипта будет соответствовать реальному времени. Но как всегда, есть ограничения.&nbsp;</span><br/><span>Что произойдет, если время самого события будет меньше чем доступное время для компенсации? Посмотрим на пример.</span>
</p>
<div class="codebox">
    <p>CODE:<span>&nbsp;</span><a href="https://3bytes.pp.ua/viewtopic.php?f=5&amp;t=4#"
                                  onclick="selectCode(this); return false;">SELECT ALL</a></p>
    <pre><code>(pressDelay =60, releaseDelay =60)

mouse.click('LEFT'); //60 + 60 + 1(накладные расходы)  =121 мс.
system.sleep(100); //100 + 1(накладные расходы) =101 мс.

общее время = 60 + 60 + 100 + 2= 222 мс.
указанное время= 100 мс.
разница = 122 мс.
</code></pre>
</div>
<p><span>В данной ситуации получается, что разница во времени больше, чем время, которое возможно компенсировать вычитанием из метода&nbsp;</span><strong
        class="text-strong">system.sleep()</strong><span>. Что же происходит в данной ситуации? Все просто, из метода&nbsp;</span><strong
        class="text-strong">system.sleep()</strong><span>&nbsp;вычитается максимально возможно время (100 мс.), а остаток будет вычтен из следующего события.</span>
</p>
<div class="codebox">
    <p>CODE:<span>&nbsp;</span><a href="https://3bytes.pp.ua/viewtopic.php?f=5&amp;t=4#"
                                  onclick="selectCode(this); return false;">SELECT ALL</a></p>
    <pre><code>mouse.click('LEFT'); 
system.sleep(0); // остаток 22 мс.
</code></pre>
</div>
<p><span>Если и из следующего события не получится вычесть нужное время, то остаток будет накапливаться, но он всегда будет ограничен параметром&nbsp;</span><strong
        class="text-strong">system.delayBuffer</strong><span>(стандартно&nbsp;</span><strong class="text-strong">delayBuffer</strong><span>&nbsp;= 100 мс.).</span><br/><br/><strong
        class="text-strong">Захват событий</strong><br/><span>Мы рассмотрели основные объекты для симуляция событий клавиатуры и мыши. Теперь рассмотрим механизм их простой записи.</span><br/><span>Все необходимые элементы управления для записи событий находятся в правом меню в пункте&nbsp;</span><strong
        class="text-strong">"Захват событий"</strong><span>.&nbsp;</span><br/><span>Элементы разделены на отдельные группы. На момент написания все элементы разделены на такие группы:</span>
</p>
<ul>
    <li>Клавиатура. Захват только клавиатуры</li>
    <li>Мышь (основные)</li>
    <li>Мышь (кнопки, колесико)</li>
    <li>Мышь (клик)</li>
    <li>Мышь + клавиатура</li>
</ul>
<p><span>Для захвата события, выберите место, куда вы хотите вставить код, выберите нужны метод захвата, (используйте контрольную клавишу, если этого требует метод захвата), произведите нужные действия, включите захват событий.</span><br/><br/><span>Захват клавиатуры</span><br/><span>Особенность захвата клавиатуры в том, что при его включении отключается возможность редактировать скрипт с клавиатуры. Если его включить, то в вывод будут дублироваться клавиши. Так при наборе "hello world" с выбранным методом для вставки имен клавиш "Захват событий &gt; Клавиатура &gt; key name" в выводе будет "H E L O SPACE W O R L D" вместо "hH eE lL lL oO SPACE wW oO rR lL dD ".</span><br/><span>Отдельно нужно выделить метод для вставки имен клавиш. Он позволит не лезь в документацию, если вы забыли как называется нужная клавиша.</span><br/><br/><span>Захват мыши</span><br/><span>Особенность захвата мыши в использовании контрольной клавиши. По умолчанию контрольная клавиша "CONTROL", ее можно изменить в настройках.</span><br/><span>Для захвата мыши необходимо выбрать нужный метод, потом зажать контрольную клавишу и произвести необходимые действия, отпустить контрольную клавишу.</span><br/><span>Способ захвата с использованием контрольной клавиши выбран для того, чтобы было проще контролировать те события, которые должны попасть в вывод.&nbsp;</span><br/><span>Учтите, что во многих приложениях контрольная клавиша "CONTROL" будет работать некорректно, так как часто CONTROL в сочетании с кнопкой мыши уже зарезервирован для других действий. Потому, для каждого приложения вам придется подбирать свою контрольную клавишу, которая не будет конфликтовать с программой.</span><br/><br/><span>Захват клавиатура + мышь</span><br/><span>Наверное, один из самых мощных инструментов для записи действий пользователя. Он способен записать события клавиатуры и мыши, обработать их надлежащим образом и сохранить это все в компактное текстовое представление.</span><br/><span>Для активации комбинированной записи необходимо включить соответствующий элемент управления и нажать контрольную клавишу, которую можно установить в окне настроек.</span><br/><span>Запись событий начинается после отпускания контрольной клавиши, а прекращается по ее нажатию. Это позволяет избежать попадания событий контрольной клавиши в список записанных событий.&nbsp;</span><br/><span>В качестве контрольной клавиши возможно установить комбинацию клавиш, но стоит учитывать, что в таком случае в список записанных событий попадут события нажатия и отпускания из списка контрольных клавиш.</span><br/><span>Для управления записью событий существую несколько опций:</span>
</p>
<ul>
    <li>Клавиши клавиатуры &ndash; Включить запись клавиатуры;</li>
    <li>Кнопки мыши &ndash; включить запись кнопок мыши;</li>
    <li>Колесико мыши &ndash; включить запись колесика мыши;</li>
    <li>Абсолютные координаты. Выбрав запись по абсолютным координатам в результат будут добавляться события для
        перемещения курсора в указанные координата, аналогично как для метода mouse.moveTo(x,y);
    </li>
    <li>Относительные координаты. Выбрав запись относительных координат в результат будут добавлены события для
        перемещения курсора относительно предыдущего события, аналогично как для метода mouse.move(dx,dy);
    </li>
    <li>Задержки. - включить в результат задержки между событиями</li>
    <li>"фиксированная частота" &ndash; включить запись с указанием фиксированной частоты записи событий передвижения
        мыши;
    </li>
    <li>"минимальное расстояние" &ndash; включить запись с указанием минимального расстояния между событиями
        передвижения мыши;
    </li>
    <li>"точки остановки" &ndash; включить запись с определением точек остановок.</li>
</ul>
<p><span>Подробнее остановимся на том, как работают последние три опции. Эти опции созданы для уменьшения объема кода. Если они выключены, то результат будет максимально приближен к действиям пользователя.&nbsp;</span><br/><span>Эти опции никоим образом не влияют на все события клавиатуры, колесика и клавиш мыши, а только отсеивают избыточные события перемещения мыши.&nbsp;</span><br/><br/><span>Опция "фиксированная частота" указывает максимальную частоту записи событий. Стандартно, курсор может изменять свое положения около 60-120 раз в секунду, что означает, что в результат каждую секунду будут добавлены 60-120 событий перемещения мыши. Указав значение равно 30, к примеру, их количество можно сократить в 4 раза. Чем ниже значение, тем больше событий будут опущены. Возможна ситуация, когда необходимое событие будет не записано.</span><br/><span>Данная опция позволяет сократить количество кода и полностью сохраняет скорость передвижения курсора. Если вы в водном месте двигали курсор быстро, а в другом медленно, то эта разница так же будет заметна. Если двигать курсор очень медленно, то данная опция не поможет сократить объем кода, так как все события так же будут попадать в результат.</span><br/><br/><span>Опция "Минимальное расстояние" указывает минимальное расстояние меду двумя событиями перемещения мыши. К примеру, минимальное расстояние установлено равным 100 пикселям, вы нажали кнопку мыши и теперь медленно ведете в сторону. Событие передвижения следующее за событием нажатия кнопки гарантировано в результат, однако в результат не попадет ни одно событие расстояние до которого будет меньше чем 100 пикселей.&nbsp;</span><br/><span>Эта опция так же поможет вам сократит объем кода. Она позволит убрать избыточные события вне зависимости от того быстро вы передвигаете мышь или очень медленно.&nbsp;</span><br/><span>Не рекомендуется устанавливать большие значения, так как результат может быть весьма непредсказуем.</span><br/><br/><span>Опция "точки остановки" позволить убрать недостатки от использования предыдущих двух опций. Если курсор простоял в данной точки не двигаясь дольше чем указанное количество мс., то события перемещения курсора в эту точку гарантировано попадет в результат.&nbsp;</span><br/><span>Таким образом, можно устанавливать любые значения для предыдущих двух опций и указывать особенно важные точки, которые обязательно должны попасть в результат, просто подержав курсов на месте некоторое время.</span><br/><span>Частота обновления стандартного монитора 60 или 120 герц, что дает примерно 8.3 и 16.6 мс. на кадр. Если вы визуально можете заметить, что курсор замер на месте, значит время его остановки было более 17 и 34 мс. соответственно. Указывать значения меньше чем время за 2 кадра нет смысла. Рекомендуется указывать время минимум за 4 кадра: 34 и 67 мс.</span>
</p>
</body>
</html>